학원 복습
-???-
scanf는 확장자가 필요하다 64비트 32비트 사이즈나 안전하지않음 자동으로 맞춰주는 scanf_s를 자주쓰자
64비트 32비트 아마 렘 수용량이 다를거다 32비트는 4기가 64비트는 원하는만큼..?아마도
crud=Create(생성), Read(읽기), Update(갱신), Delete(삭제)중요하다 
선택문은 이프,스위치,삼항연산자 총 3가지다

-1/16~1/17-
반복문은 총 4가지의 순서로 나누어진다
1 초기화 2조건 3코드작성 4증감문
반복문은 총 2가지로 나누어진다
for,while문으로 나누어진다
포문은 for([1번] ; [2번] ; [4번]){[3번]}
와일문은 [1번]
while([2번]){[3번] [4번]}이런형식이다

반복문 조건에 알파벳도 넣을수있다
ex)for(int i = A ;  i<Z ; i ++)
//맞..나? 나중에 테스트하길바람

렉이나 그런건 반복문이 잡아먹음 그래서 최적화할때 반복문이나 초기화 된값을 또 초기화시키지 않는다
선언할때 이름을 신중하게 지어라 제대로 안지으면 욕먹는다 강사님도 욕하면서 빡칠수있다는걸 알수있게됐다
강사님도 빡쳐서 욕하는거보면..

항상 개발자들이 독심술사도아니고 코드를 보여줘야지 그 코드가 뭐가 잘못된지 알수있다

wsl설치

리눅스 이것저것 해라


깃허브는 사소한거라도 좋으니 추억회상겸 구경할수도있고 하니 잡다한거라도 넣자
콘솔라스 폰트 편하다 자주 쓰자

항상 변수 초기화 꼭 하자..

폰트는 Consolas추천 진짜 잘보인다
------------------------------
1/23~1/24
배열에 변할수있는 상수는 절대 안들어간다
ex)int a;
int s[a];
배열은 define을써서 전처리기해서 넣거나 해야한다 넣을거면..



ex)
[] [] [] []
2 2 2 2
배열의 이름은 첫번째 주소값이다
배열은 넘어갈때 앞에 자료형(인트나 short dobule)만큼 점프한다 10개의공간이있다면 short로 자료형으로 받으면 1*2/2*2/3*2
short a[4]; 하고
printf("%d", a[0]);하면
[] [] [] []
2 2 2 2
요기 첫번쨰 주소값을 나타내는거다
short array[4];
*(array+4)=10 ->2*4 즉 8만큼 점프 array[10]=20바이트에서 array[4]=8바이트로 뛴다는소리
[] [] [] [] [] [] [] [] [] []
2 2 2 2 2 2 2 2 2 2
     (요기)
각 배열마다 2바이트 씩할당
요약하자면 포인터앞에 쇼트나 플로트나 그런것들은 주소에 넣는거다

short* point = malloc(sizeof(short)*11);
꼭 sizeof를 쓰자 이유 64비트나 32비트로 가면 숫자가 불변하는 수라도 바뀔수있기에  꼭 절댓값말고 사이즈 오브를 쓰자
포인터로 표현하면 이렇게 배열 할당이 가능하다
        for (int i = 0; i <= 10; i++) {
		point[i] = i;
		printf("%d\n", point[i]);
	}
	for (int i = 1; i <= 10; i++) {
		*(point + i) = i;
		printf("%d\n", point[i]);
	}
2가지 방법이 있다


공백열 받는 (띄어 쓰기)는 scanf_s("%[^\n]s", str, sizeof(str));
이렇게 하면된다
매개변수=함수호출 넘어가기전에 저장하는 변수
----------------------------------------------------------------------------
포인터 복습 및 다시 공부
자료형에는 char=1, short=2, int=4, long=4, longlong=8, flaot=4, double=8, longduble=8,12 16 즉 8이상
단위는 Byte 바이트
float, double ,long double는 실수(부동소수점?)
char은 문자 
short, int, long, long long은 정수형 자료

cpu, memory, hdd, sdd

cpu는 Central Processing Unit(센트럴 프로세싱 유닛)중앙처리장치이고
레지스터라는 임시공간이 있다

memory=작업테이블이라고 생각하면 편하다 이제 각 구역별로 나눈 작업테이블로 
Random Access Memory(랜덤 어세스 메모리)주기억장치가 있다
메모리 구조 
stack=지역변수, 매개변수
heap=동적할당
deta=전역변수, 상수
code segement=함수

HDD는 Hard Disk Drive의 약자다
SDD는 Solid State Drive의 약자다
둘다 보조기억장치다

cpu랑 memory는 통신이 가능하다 하지만 보조기억장치와는 통신이 불가능하다
보조기억장치와 memory는 통신이 가능하다 하지만 cpu랑은 통신이 불가능하다

1byte=2의8제곱
2byte=2의 16제곱
4byte= 2의 32제곱=32비트 똑같은말이다 64비트는 2의 64제곱

요약하면 
1.자료형은 메모리 크기와 관련이 있다
2.레지스터는 cpu안에있는 임시기억 장소이다
3.메모리는 16진수 표기다
4.int a;에서 &a는 시작주소를 나타낸다 (위에 학원에 배운거 참조)
--------------------------------------------------------------------
포인터 복습 2일차
일반 선언
int a=20;
int=자료형 a=변수 20=값 이렇게 정리된다

포인터
int* p=&a;
int*=자료형 p=변수 &a=값
즉 int*는 &a를 쓰기위한 자료형일뿐이다
이럴때 여기서 포인터는 p이다
여기서 *p의값은 무엇이냐 하면 20이다

*p=N(번지수)를써서 자기가 원하는 값을 가르키게 만들수있다
선언할떄 자료형이랑 포인터 자료형이 일치해야한다
--------------------------------------------------------------------
함수 학원
함수를 만들때
1)반환 타입
2)함수 명 (이름)
3)파라미터 ( 값 전달( f(x)<--x) 즉 매개변수
4){ }

ex)int test(){
}
1)int
2)test
3)() 없다
4){}

함수를 왜 쓰는가
1.반복 작업을안할려고
2.노가다 귀찮음
3.만들어진 인스턴트음식?

### 함수는 (3)
정수 실수 문자 보이드
보이드는 리턴이없다
*point point를 리턴한다

c언어는 절차 지향적언어다 함수는 위에다가 선언하고 밑에쓰거나 
아니면 위에 선언하고 값을입력하자
