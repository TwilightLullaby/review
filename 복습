복습
-???-
scanf는 확장자가 필요하다 64비트 32비트 사이즈나 안전하지않음 자동으로 맞춰주는 scanf_s를 자주쓰자
64비트 32비트 아마 렘 수용량이 다를거다 32비트는 4기가 64비트는 원하는만큼..?아마도
crud=Create(생성), Read(읽기), Update(갱신), Delete(삭제)중요하다 
선택문은 스위치,삼항연산자

-1/16~1/17-
반복문은 총 4가지의 순서로 나누어진다
1 초기화 2조건 3코드작성 4증감문
반복문은 총 2가지로 나누어진다
for,while문으로 나누어진다
포문은 for([1번] ; [2번] ; [4번]){[3번]}
와일문은 [1번]
while([2번]){[3번] [4번]}이런형식이다
렉이나 그런건 반복문이 잡아먹음 그래서 최적화할때 반복문이나 초기화 된값을 또 초기화시키지 않는다
선언할때 이름을 신중하게 지어라 제대로 안지으면 욕먹는다 개발자강사님도 욕하면서 빡칠수있다는걸 알수있게됐다
강사님도 빡쳐서 욕하는거보면 
항상 개발자들이 독심술사도아니고 코드를 보여줘야지 그 코드가 뭐가 잘못된지 알수있다
wsl설치
리눅스 이것저것 해라

깃허브는 사소한거라도 좋으니 추억회상겸 구경할수도있고 하니 잡다한거라도 넣자
콘솔라스 폰트 편하다 자주 쓰자
------------------------------
#### 1/24 4
하지만에 배열에안들어감
배열은 define을써서 전처리기해서 넣어야한다
포인터앞에 쇼트나 플로트나 그런것들은 주소에 넣는거다
ex)
[] [] [] []
2 2 2 2
배열의 이름은 첫번째 주소값이다
배열은 넘어갈때 앞에 자료형(인트나 short dobule)만큼 점프한다 10개의공간이있다면 short로 자료형으로 받으면 1*2/2*2/3*2 
[] [] [] []
2 2 2 2
short array[4];
*(array+4)=10 ->2*4 즉 8만큼 점프 array[10]=20바이트에서 array[4]=8바이트로 뛴다는소리
[] [] [] [] [] [] [] [] [] []
2 2 2 2 2 2 2 2 2 2
각 배열마다 2바이트 씩할당
short* point = malloc(sizeof(short)*11);
꼭 sizeof를 쓰자 이유 64비트나 32비트로 가면 숫자가 불변하는 수라도 바뀔수있기에  꼭 절댓값말고 사이즈 오브를 쓰자
포인터로 표현하면 이렇게 배열 할당이 가능하다
/*for (int i = 0; i <= 10; i++) {
		point[i] = i;
		printf("%d\n", point[i]);
	}*/
	for (int i = 1; i <= 10; i++) {
		*(point + i) = i;
		printf("%d\n", point[i]);
	}
