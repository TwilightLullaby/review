https://goodmilktea.tistory.com/96
9. 인터넷 프로토콜(IP)과 주소체계
전공공부/컴퓨터 네트워크 2020. 2. 28. 00:18
목차

1. IP 패킷 구성과 기능

2. IP (IPv4) 주소 체계

3. IP 주소의 클래스

4. 서브넷 기법

 

9.1 IP 패킷 구성과 기능
IP(Internet Protocol)란?

- IP 주소체계를 이용하여 인터넷에 연결된 모든 호스트들과 데이터통신이 가능해짐

- IP 계층은 네트워크 계층에 해당하는 프로토콜.

 

9.1.1 IP 데이터그램의 형식과 기능
- IP에서 사용하는 패킷을 ‘데이터그램 (datagram)’이라 함

- IP datagram은 헤더 부분과 사용자 데이터 부분으로 구분 됨 à [그림9-2]

- IP datagram의 길이는 가변적이고, 기본 헤더의 크기는 20바이트이며, 옵션 영역을 사용하면

    최대 60바이트까지 확장가능


 

 

9.2 IP(IPv4) 주소체계
9.2.1 IP 주소의 표현
- IP(IPv4) 데이터그램은 전송 측과 목적지 주소 영역이 각각 32비트로 구성되고, IPv6인 경우 128비트 영역으로 확장됨

- IPv4는 기본적으로 클래스(class)로 구분되는 주소체계를 취함

- 심볼화된 이름, 즉 ‘도메인 이름’을 사용함

- 응용 프로그램에서 사용자가 심볼화된 주소를 입력하면, 이 주소는 이진수 형태의 주소로 변환되고 이 변환된 결과가 메모리에 저장됨

 

- 이진 형태의 주소 표현을 사용하면, 심볼화된 이름을 사용하는 것보다 시스템의 메모리 사용이 줄어들어 네트워크를 통한 데이터 전송시간을 줄일 수 있음

 

- 호스트 컴퓨터 A는 IP 주소체계를 이용해서 호스트 컴퓨터 B로 데이터 패킷을 전송  [그림 9-5]

    . 호스트 A는 호스트 B가 지리적으로 어느 곳에 위치하는지 알 필요가 없으며, 다만 인터넷 프로토콜 주소체계에 따라 패킷의 경로를 결정하면 됨

    . IP 주소가 네트워크 내에서 유일한 식별자의 역할


 

9.2.2 IP주소란?
네트워크 환경에서 컴퓨터(노드)간 통신하기 위해 각 커뮤터에 부여된 네트워크 상 주소

 

윈도우 검색창에 CMD를 치고 명령프롬프트 창을 열어, ipconfig라는 명령어를 검색하면 IP정보가 나온다.

 


IPv4주소가 곧 내 컴퓨터의 IP주소이다. 

여기서 네트워크 주소는 192.168.xxx 까지이고 1은 나만의 호스트IP라고 할 수 있다.

 

쉽게 예를 들어서 인천광역시 연수구 인천대학교 B동 101호 라는 주소가 있다면 천광역시 연수구 인천대학교 B동까지는 네트워크 주소이고 101호는 호스트 주소라고 생각하면 된다. 즉 공통적인 부분(중복이 있는)은 네트워크 주소이고, 식별할 수 있는 부분(중복이 없고 유일무이함)은 호스트 주소이다.

 

이때 호스트 주소의 중복이 없다는 뜻은 당연히 같은 네트워크 상에서 중복이 없다는 뜻이다.

 

2) 32자리로 이루어진 2진수, IP

IP 주소에서 IPv4주소는 32자리 2진수로 표현하므로 주소의 범위는 0~2^32 (약 42억 ) 이다.


위 예제와 같이 IP주소를 표현할 수 있다.

 

9.3 IP주소의 클래스 
9.3.1 IP주소의 클래스란?
하나의 네트워크 안에 IP들은 네트워크 영역은 같아야하고, 호스트 IP는 서로 다르다. 예를들어 203.240.100.1 에서 203.240.100 은 네트워크 영역이고 1 은 호스트 IP라는 사실을 알 수 있다. 여기서 어떻게 네트워크 주소와 호스트 주소를 구분할 수 있을까? 바로 클래스 때문이다. 


203.240.100.1이라는 IP주소가 C클래스 이기 때문에 203.240.100 은 네트워크 주소이고, 1은 호스트 주소란 사실을 알아낸 것이다. 이렇게 IP주소에는 클래스라는 개념이 있고 이 클래스의 개념을 알아야 어디까지가 네트워크 영역이고 호스트 영역인지 알 수 있다.

 

즉 클래스는 하나의 IP주소에서 네트워크 영역과 호스트 영역을 나누는 방법이라고 할 수 있다.

 

일반적으로 IP주소를 3개의 클래스로 나누는 이유는 네트워크 크기에 따른 구분이라 생각하면 된다.

하나의 네트워크에서 몇 개의 호스트 IP까지 가질 수 있는가에 따라서 클래스를 나눌 수 있다.

 

9.3.2 A클래스, B클래스, C클래스
A클래스
A클래스는 하나의 네트워크가 가질 수 있는 호스트 수가 가장 많은 클래스이다. IP 주소를 32자리 2진수로 표현했을때, 맨 앞자리수가 항상 0인 경우가 바로 A클래스이다. 즉 0XXX XXXX . XXXX XXXX . XXXX XXXX . XXXX XXXX 와 같이 되어있다.

 

A클래스에서 가질 수 있는 IP 범위는 0000 0000. 0000 0000. 0000 0000. 0000 0000 ~ 0111 1111. 1111 1111. 1111 1111. 1111 1111 까지다. 이를 십진수로 표현하면 0.0.0.0 ~ 127.255.255.255

A클래스에서 첫번째 옥테드는 네트워크 부분을 나타내고 나머지 부분은 호스트 부분을 나타낸다.

 

또 A클래스에서 네트워크 주소는 가장 작은 네트워크인  1.0.0.0 과 가장 큰 네트워크인 126.0.0.0 까지로 규정되어 있다. (127은 제외)

 

IP주소 중에서 1부터 126으로 시작하는 네트워크는 A클래스라고 생각하면 됩니다. 그리고 호스트 주소가 가질 수 있는 갯수는 (2^24) - 2 개 (-2 이유는 모두가 1인경우 브로드캐스트 주소로 사용하고 모두 0인경우엔 네트워크 주소로 사용하기 때문)

 

예를 들어 A클래스로 13.0.0.0 네트워크 주소를 할당 받았다고 한다면 여기서 13. 은 네트워크 부분이고 나머지 0.0.0 에 호스트 IP를 할당 할 수 있다. 십진수 0.0.0 은 2진수로 표현하면 총 24개의 2진수로 표현이 가능하고 이는 곧 2^24 개의 호스트 IP를 가질 수 있다는 뜻이다. 

 

십진수로 나타내면 13.0.0.0 ~ 13.255.255.255 . 하지만 여기서 13.0.0.0 은 네트워크 주소를 표현하기 위해서 사용되어야 하므로 호스트IP로 사용하면 안된다. 또, 13.255.255.255 역시 브로드캐스트 주소로 사용하기 때문에 호스트 IP로 사용하면 안된다. 따라서 (2^24) - 2 를 해주는 것이다. B클래스, C클래스도 같은 원리를 적용하며 네트워크 주소 범위, 호스트 주소 범위만 다르다고 생각하면 된다.

 

B클래스
 

B클래스는 반드시 10으로 시작합니다. 2진수로 표현하면

10XX XXXX . XXXX XXXX . XXXX XXXX . XXXX XXXX  

 

B클래스의  IP 범위는 128.0.0.0 ~ 191.255.255.255 까지이고

네트워크 범위는10XX XXXX . XXXX XXXX  에서 x들이 가질 수 있는 경우의 수 이다.  (2^14 개)

호스트 주소 범위는 XXXX XXXX . XXXX XXXX  에서 x들의 경우의 수인 (2^16) - 2 개 이다. 

(-2 는 네트워크 주소, 브로드캐스트 주소 사용으로 인해 호스트 주소에서 제외해야 한다.)

 

C클래스
 

C클래스는 반드시 110으로 시작합니다. 2진수로 표현하면

110X XXXX . XXXX XXXX . XXXX XXXX . XXXX XXXX  

 

C클래스의 IP 범위는 192.0.0.0 ~ 223.255.255.255 까지이고

네트워크 범위는 110X XXXX . XXXX XXXX . XXXX XXXX  에서 x들이 가질 수 있는 경우의 수 이다. (2^21 개)

호스트 주소 범위는 XXXX XXXX 에서 x들이 가질 수 있는 경우의 수 (2^8 )-2 개 이다.

(-2 는 네트워크 주소, 브로드캐스트 주소 사용으로 인해 호스트 주소에서 제외해야 한다.)

 

정리하자면

구분 

2진수 시작은? (s 네트워크, h 호스트)

네트워크 시작번호 (개수)

호스트 범위 (개수) 

 A클래스

0sss ssss. hhhh hhhh. hhhh hhhh. hhhh hhhh

(0 시작, 네트워크 : 7bit, 호스트 : 24bit)

 1 ~ 126 시작 

(2^7 -1 개 : 127은 제외라 -1)

 2^24 -2 

(-2 네트워크, 브로드캐스트 주소 제외)

 B클래스

10ss ssss .ssss ssss. hhhh hhhh. hhhh hhhh

(10 시작, 네트워크 : 14bit, 호스트 : 16bit)

 128.0 ~ 191.255 시작

(2^14 개)

2^16 -2 

(-2 네트워크, 브로드캐스트 주소 제외)

 C클래스

110s ssss. ssss ssss. ssss ssss. hhhh hhhh

(110 시작, 네트워크 : 22bit, 호스트 : 8bit)

 192.0.0 ~ 223.255.255 시작

(2^22 개)

 2^8 -2 

(-2 네트워크, 브로드캐스트 주소 제외)

 

9.4 서브넷 기법
9.4.1 서브네팅이란? (Subnetting)
서브네팅은 네트워크 관리자가 네트워크 성능을 성능을 향상시키기 위해, 자원을 효율적으로 분배하는 것이다. 여기서 자원을 효율적으로 분배한다는 것은 네트워크 영역과 호스트 영역을 분할 하는 것이라고 생각하면 된다. 네트워크 측면에서 보자면, 너무 큰 브로드캐스트 도메인은 네트워크 환경에서 패킷전송을 느리게하고 성능저하를 발생시킨다. 따라서 네트워크를 쪼개서 통신 성능을 보장해야한다. 또한 IP는 32자리 2진수로 표현할 수 있는데 이 말은 결국 최대 2의 32승만큼의 표현만 가능하다는 뜻이다. 즉, 자원의 한계가 존재한다는 뜻이고 결국 제한적인 자원으로 인해 주소에 낭비 없이 아껴써야 한다. 그래서 서브넷마스크라는 개념이 등장한다. 서브넷 마스크는 필요한 네트워크 주소만 호스트 IP로 할당 할 수 있게 만들어 네트워크 낭비를 방지한다. 이를 서브네팅이라 한다.

 

*IP의 특징 : 하나의 IP는 네트워크 부분 + 호스트 부분으로 구성되어 있다. 하나의 네트워크 즉 하나의 브로드캐스트 도메인에 있는 IP끼리 통신하기 위해선 네크워크 영역이 같아야하며, 호스트 IP는 달라야한다. 호스트 IP가 다르지 않다면 IP 충돌이 나지 않을까? 당연히 통신하기 위해선 네트워크 영역이 같아야 한다. 하지만! 네트워크 영역이 다르다고 해서 통신할 수 없을까? 네트워크 영역이 달라도 라우터나 게이트웨이와 같은 통신장비를 통해 통신할 수 있다! 다만 라우터와 네트워크장비 없이 통신할 수 있는 영역을 우리는 브로드캐스트 도메인이라고 하고 하나의 네트워크 영역에는 당연히 네트워크 영역은 같고, 호스트 IP는 자신의 노드를 식별할 수 있도록 다른 호스트 IP와 달라야 한다. 호스트 IP는 마치 주민번호와 같은것! 중복할 될 수 없는 유일무이한 것이다.

 

예를 들어 192.168.0.3 과 192.168.0.4 를 보면 192.168.0 은 네트워크 영역이고 3과 4는 호스트 IP이다. 이를 해석하면 192.168.0 이라는 네트워크 영역에서 서로 통신할 수 있는 3과 4가 존재한다고 보면 된다.

 

9.4.2 서브넷마스크 (Subnet Mask)
쉽게 생각해 볼 수 있다. 성형외과에서 코수술을 한다고 했을때, 환자 얼굴위에 수술 마스크를 덮는다. 해당 마스크는 코만 보이고 눈,입,볼 등 코를 제외한 부분은 전부 가려주어 의사가 코에만 집중할 수 있게 된다. 이와 비슷하게 어느 한 네트워크에서 1~100까지 IP를 할당받을 수 있고 우리가 필요한 IP가 20개 정도라고 가정할 때, 굳이 1~100까지 IP를 줄 필요가 없다. 최소 1~20까지만 IP를 할당하면 된다. 그럼 나머지 21~100은 사용자가 신경쓰지 않게 끔, 서브넷 마스크로 가려버린다고 생각하면 이해하기 쉽다.

 

9.4.3 서브넷마스크 표시방법
서브넷마스크는 기본적으로 1과 0으로만 구성되어 있다. IP는 32자리 2진수로 표현하며 서브마스크 또한 IP와 크기만큼 32자리 2진수로 표현할수있다. 굳이 IP보다 클 필요가 없고 작으면 마스크를 하는 의미가 없다. 

 

서브넷마스크는 1과 0으로 이뤄져있고, 1이 연속으로 나와야한다. 무조건 11110000 이런식으로 1을 표현하기 위해선 1이 연속으로 나와야 한다. IP주소가 만약 192.168.0.1/24 라고하면 이는 C클래스이고 기본 디폴트 마스크는 255.255.255.0 이다. 디폴트 마스크도 서브넷 마스크이다. 255.255.255.0은 우리가 알기 쉽게 10진수로 표현했을 뿐 2진수로 바꾸면 결국 1111 1111.1111 1111.1111 1111.0000 0000 이다. 여기 1이 연속으로 24개 있다. 즉  192.168.0.1/24에서 IP 뒤에 /24 라는 표현은 서브넷 마스크 255.255.255.0을 통해 할당한 IP주소라는 뜻이된다. 1은 네트워크 영역으로 사용하겠다는 뜻이고, 0은 호스트 IP로 사용하겠다라는 뜻이다. 즉 사용자에게 0이 표현된 부분만 호스트 IP를 할당할 수 있게 만들겠다는 뜻이다.

 

9.4.4 기본 서브넷마스크, 서브넷네트워크, 논리 AND계산 
기본 서브넷마스크와 서브넷 네트워크에 대해 잠깐 알아야 한다. 예를 들어 210.100.100.1 이라는 IP주소가 있다. 이 주소는 C클래스이다. C 클래스를 사용하고 있다는 뜻은 결국 서브넷마스크(디폴트 마스크)를 사용한다는 말과 같다.

(C클래스가 다음과 같이 표현되기 때문에 110X XXXX . XXXX XXXX. XXXX XXXX.XXXXXXXX ) 결국호스트 IP로 쓰이는 구간은 서브넷 마스크를 통해 호스트IP를 할당하는 범위와 같다고 할 수 있다.

 

즉, C클래스를 그대로 사용한다는 것은 C클래스 네트워크를 쪼개지 않고 그대로 하나의 네트워크에 할당할 수 있는 2^8-2개의 호스트 IP를 사용하겠다는 뜻이고 255.255.255.0 이 기본 서브넷 마스크가 된다. 또한, 192.0.0 ~ 223.255.255 까지의 네트워크가 곧 서브넷 네트워크가 된다. 별개의 서브넷마스크를 생성하지 않아도 기본적으로 적용되어 있는게 기본 서브넷마스크이고, 기본서브넷마스크로 쪼개진 네트워크 주소를 서브넷 네트워크 라고 한다. 

 

따라서 IP 210.100.100.1 기본서브넷마스크 : 255.255.255.0 서브넷네트워크 : 210.100.100.0 이다.

B클래스의 기본서브넷마스크는 그럼 255.255.0.0 가 되고  A클래스는 255.0.0.0 라고 할 수 있다.

 

IP 210.100.100.1 를 2진수로 표현하면 다음과 같다.

 

1101 0010. 0110 0100. 0110 0100. 0000 0001 = 210.100.100.1 (IP주소)

1111 1111. 1111 1111. 1111 1111. 0000 0000 = 255.255.255.0 (C클래스 기본서브넷마스크)

1101 0010. 0110 0100. 0110 0100. 0000 0000 = 210.100.100.0 (서브넷네트워크)

 

 

 

위에서 알 수 있듯이 IP주소와 서브넷마스크를 논리 AND 연산하면 서브넷네트워크를 구할 수 있다.

 

논리 AND 연산은 1 AND 1 = 1, 1 AND 0 = 0, 0 AND 1 = 0, 0 AND 0 = 0.

 

이번엔, 150.150.100.1 에 대해서 알아보자

 

1001 0110. 1001 0110. 0110 0100. 0000 0001 = 150.150.100.1 (IP주소)

1111 1111. 1111 1111. 1111 1111. 0000 0000 = 255.255.255.0 (C클래스 기본서브넷마스크)

1001 0110. 1001 0110. 0110 0100. 0000 0000 = 150.150.100.0 (서브넷네트워크)

 

뭔가 이상하다고 느낄 수 있다. 150.150.100.1 은 분명 B클래스인데, 서브넷 마스크가 C클래스이기 때문이다. 150.150.100.1의 기본서브넷마스크인 255.255.0.0을 사용하지 않고 C클래스 255.255.255.0 을 사용한다는 것은 B클래스 주소를 마치 C클래스 주소처럼 사용하겠다는 뜻이다. (만약 서브넷 마스크를 사용하지 않았다면 해당 IP주소의 네트워크 주소는 150.150.000.0 이다.)

 

다시말해 B클래스에 의해서 150.150 까지가 네트워크 영역이고 나머지 3,4번째 옥태드가 호스트 영역인데, C클래스 기본 서브넷마스크인 255.255.255.0을 씌우면서 150.150.100까지 네트워크영역이 되고 4번째 옥태드만 호스트 IP를 배정할 수 있게 만든 것 이다.

 

즉 네트워크 영역을 늘리고 호스트 영역을 줄이겠다는 뜻을 내포하고 있다는 것을 눈치채야 한다. 이렇게 하나의 주소에 서브넷 마스크를 씌워서 자신에게 맞는 네트워크를 만드는 것을 서브네팅이라고 합니다. (참고로 서브넷마스크로 나뉘어진 서브넷네트워크간 통신은 라우터를 통해서 통신이 되어야 한다. 다른 말로 서브넷네트워크는 하나의 독립적인 네트워크다.)

 

9.4.5 네트워크 영역, 호스트 영역 범위는?
서브넷마스크를 통해서 얻을 수 있는 서브넷네트워크 갯수와 각 서브넷네트워크에 할당할 수 있는 호스트 갯수에 대해서 알아보자. 전산시험에 단골 출제....

 

201.222.5.0 IP를 255.255.255.248 서브넷마스크(기본서브넷마스크가 아닌 사용자가 만든 서브넷마스크)에 씌워보자

 

11001001 11011110 00000101 00000000 = 201.222.5.0 (IP 주소)

11111111 11111111 11111111 11111000 = 255.255.255.248 (서브넷마스크)

 

11111111 11111111 11111111 (기본 C클래스가 가질 수 있는 네트워크 영역 )

11111 (사용자 지정한 네트워크영역 or 범위)

000 (사용자가 지정한 호스트영역)

 

위와 같이 서브넷마스크를 적용했을 때, 서브넷네크워크는 몇개가 있을까?

파란색부분이 바로 서브넷네트워크가 가질 수 있는 범위다. 즉 00000 ~ 11111 (2^5) 까지 계속 바꿔 넣으면 32개의 서브넷네트워크로 쪼갤 수 있다. 그럼 각 서브넷마스크가 가질 수 있는 호스트 IP 갯수는 몇개일까? 초록색 부분이다. 000 ~ 111 (2^3) 까지 계쏙 바꿔 넣으면 8개를 가질 수 있다. 하지만 네트워크 주소와 브로드캐스트 주소를 써야하기 때문에 -2 를 해줘야 한다.  결국 호스트 IP 갯수는 6개라고 할 수 있다. 

 

 

 다시 생각해보자. 서브넷마스크는 하나의 IP에서 사용자의 입맛에 맞게 네트워크 영역과 호스트 영역을 나눠준다. 기본서브넷네트워크도 물론 네트워크 영역과 호스트 영역을 나눠주기 때문에 서브넷마스크라고도 한다. 하지만 진정한 의미의 서브넷마스크는 A클래스, B클래스, C클래스의 기본 서브넷마스크에서 가질 수 있는 네트워크영역과 호스트영역을 더 쪼개서 더 효율적으로 서브네팅하는 것이다. 그렇기 때문에 위에 처럼 C클래스(3옥테드까지만 네트워크로 사용함) 이상으로 4옥테드 영역에 5자리 2진수를 네트워크 영역으로 확대하고! 호스트 영역을 3자리 2진수를 할당함으로써 기본서브넷마스크로 커버할 수 없었던 서브네팅을 구현할 수 있니다.

 

예제 


 


위 문제에서 풀이를 덧붙이자면 기존 네트워크보다 네트워크 범위가 1옥텟만큼 더 넓어졌으므로 기존네트워크가 서브네트워크로 2^8 = 256 개로 더 쪼개져서 표현되었다는 의미이다. 그리고 하나의 서브넷 당 호스트 영역이 나머지 2^8-2로 표현 된다. (브로드 캐스트와 네트워크 주소는 제외시켜야 하므로 -2)

 
* * *
* * *
* * *
OSI7계층 tcp/ip
===
https://velog.io/@inyong_pang/OSI-7-%EA%B3%84%EC%B8%B5%EA%B3%BC-TCPIP-%EA%B3%84%EC%B8%B5
OSI 7 Layer
Open System Intercon-nection
시스템 상호 연결에 있어 개방(열려있다, 표준)모델을 뜻한다
실제 인터넷에서 사용되는 TCP/IP OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록
단순하된 현실화의 과정에서 채택된 모형
OSI 7 Layer 목적
표준과 학습도구
표준화를 통해 장비별 이직적인 포트, 프로토콜을 구별
OSI 계층별 기능과 통신의 과정을 정립하여 교육하기 위한 목적으로 사용
Encapsulation & Decapsulation


Encapsulation
데이터를 전송할 때 각각의 레어마다 인식할 수 있는 헤더를 붙이는 과정
2계층(Data layer, 데이터링크계층)에서는 오류제어를 위해 데이터의 뒷부분에도 일부 데이터가 추가됨
Decapsulation
수진된 데이터가 각각의 레이어를 따라 올라가면서 헤더가 벗겨지는 과정
OSI 7 Layer별 Protocol과 기능


OSI 7계층에서 PDU(Process Data Unit)란 각 계층에서 전송되는 단위
계층 별 PDU
1계층 : Bits
2계층 : Frames
3계층 : Packets
4계층 : Segments
5~7계층 : Data
각 계층별 프로토콜 기능
분할 : 큰 용량의 데이터를 전송하기 위해 데이터를 나누는 기능
재조립 : 분할된 데이터를 사용하기 위해 재조립 하는 기능
캡슐화 : 각 계층을 거칠 때 마다 각 계층의 헤더가 계층별로 붙으며, 캡슐화를 진행
순서 제어 : 전송되는 데이터의 순서를 조율하고 이를 통해 데이터가 중복되거나 유실되는지 체크
흐름 제어 : 송신되어 데이터의 양과 전송률을 제한하는 기능
오류 제어 : 데이터가 올바르게 수신되었는지 에러 검출 코드를 통해 체크하는 기능
1계층 - 물리 계층(Physical Layer)


전기적, 기계적 특성을 이용하여 통신 케이블로 전기적 신호(에너지)를 전송
비트(Bit)단위의 PDU, 1(On)/0(Off)의 인코딩 전압 및 케이블 사양 핀의 수 등을 정의한 계층
단지 데이터 전달의 역할
1계층 장비 : 케이블, 리피터, 허브
2계층 - 데이터 링크 계층(Data Link Layer)


물리적인 연결을 통하여 인접한 두 장치의 신뢰성 있는 정보 전송을 담당
프레임(Frame)단위의 PDU, MAC주소와 제어정보를 전송, 헤더를 통해 캡슐화 또는 캡슐화 해제
정보의 오류와 흐름을 관리하여 안정된 정보를 전달
IEEE802.2(LLC), IEEE802.3(CSMA/CD), IEEE802.5(Token Ring) 등등
2계층 장비 : 브릿지, 스위치
3계층 - 네트워크 계층(Network Layer)


중계 노드를 통해 전송하는 경우 어떻게 중계할 것인가를 규정
패킷(Packet)단위의 PDU, 패킷은 목적지까지 경로를 설정, 헤더를 통해 캡슐화 또는 캡슐화 해제
데이터를 목적지까지 가장 안전하고 빠르게 전달.
IP(Internet Protocol), 라우팅(Routing), OSFP, BGP 등등
3계층 장비 : 라우터, L3 스위치
4계층 - 전송 계층(Transport Layer)


종단 간(End-to-End)에 신뢰성 있고 정확한 데이터를 전송
세그먼트(Segement)단위의 PDU, 종단 간의 에러복구와 흐름제어 담당, 헤더를 통해 캡슐화 및 캡슐화 해제
TCP(Transmission Control Protocol), UDP(User Datagram Protocol) 등등
4계층 장비 : L4 스위치
5계층 - 세션 계층(Session Layer)


통신장치 간 상호작용 및 동기화를 제공
연결 세션에서 데이터 교환과 에러 발생 시의 복구를 관리. 즉, 논리적인 연결을 담당
헤더를 통해 캡슐화 및 캡슐화 해제
4계층과 5계층을 경계가 모호함
NetBIOS, SSH, Appletalk 등등
6계층 - 표현 계층(Presentation Layer)


데이터 표현에 차이가 있는 응용처리에서 제어 구조를 제공
데이터의 표현 차이
전송하는 데이터의 인코딩, 디코딩, 암호화, 코드 변화
헤더를 통해 캡슐화 및 캡슐화 해제
ASCII, JPEG, MPEG 등등
7계층 - 응용 계층(Application Layer)


사용자와 가장 밀접한 계층, 인터페이스(Interface) 역할
응용 프로세스 간의 정보 교환
전자메일, 인터넷 서비스, 동영상 플레이어 등의 어플리케이션
TCP/IP 4계층




ARPANET이 개발된 이후 현재의 인터넷으로 발전해나가는 과정에서 대부분의 데이터 통신이 TCP와 IP기반으로 이루어졌기 때문에 인터넷 프로토콜 그 자체를 표현하는 용어
사실상 인터넷 프로토콜을 대표하는 용어로 사용
TCP/IP는 현재 인터넷에서 컴퓨터들이 서로 정보를 주고받는데 쓰이는 통신규약(프로토콜)의 모음
1계층 - 네트워크 액세스 계층(Network Access Layer)
OSI 7계층의 물리계층과 데이터 링크 계층에 해당
물리적인 주소로 MAC을 사용
CSMA/CD, MAC, LAN, X25, 패킷망, 위성 통신, 다이얼 모뎀, LAN, 패킷망 등
Ehternet(이더넷), Token Ring, PPP 등등
2계층 - 인터넷 계층(Internet Layer)
OSI 7계층의 네트워크 계층에 해당
통신 노드 간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당
IP, ICMP, ARP, RARP, OSPF, BGP 등등
3계층 - 전송 계층(Transport Layer)
OSI 7계층의 전송 계층에 해당
통신 노드 간의 연결을 제어하고, 신뢰성 있는 데이터를 전송
TCP, UDP 등등
4계층 - 응용 계층(Application Layer)
OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당
TCP/UDP 기반의 응용 프로그램을 구현할 때 사용
SMTP, FTP, HTTP, SSH, DNS 등등


 
요약
===
osi에서 ip는 3계층이(네트워크) 잡아먹는다
tcp ip에서는 2계층이(인터넷) 잡아먹는다
ip클래스의 기준은 처음 아이피 주소 처음자리이다 192.168.62는 네트워크 id 그 다음 주소는 호스트 id 이게 c 클래스이다
a클래스는 192 여기는 네트워크 id는 한개 나머지는 호스트 id 즉 대기업같은거다 네트워크 id는 적지만 호스트 id는 짱많기에 제일 비싸고 제일 효율좋다
ip는 각 8byte? 이다 
![image](https://user-images.githubusercontent.com/76859458/114508382-3fc35180-9c6f-11eb-91d1-7a0f0eeb4ac3.png)

그러기에 예를들어 클래스c라고 치면 호스트 id 갯수는 2의8제곱 
b는 16제곱
a는 24제곱 
ㅇㅋ?
192~221
대표주소는 192
브로드캐스트는 221
서브넷마스크는 1들 각 위치 더한거 1111 0000 128+64+32+16=서브넷마스크

사설아이피는 공짜
공인아이피는 유로

아이피 만드는곳은 IANA
사설아이피
10.0.0.1 
172.16.0.1
192.168.0.1
앞에 시작될때 이런 아이피가 붙는다
![image](https://user-images.githubusercontent.com/76859458/115327877-aba33e00-a1ca-11eb-88fc-ef26b7b36d76.png)
isp=Internet Service Provider=kt,lg,sk
공인아이피는 kt,lg,sk같은거다
★NAT->Network address 트렌스
사설아이피를 공인아이피로
공인아이피를 사설아이피로 바꾸는거는 NAT기술이다

heartbeat 만들기
1.셋팅에서 add누르고 네트워크 어뎁터에서 host only로 바꾸기
2.ncpa.cpl에서 세컨드는 10.10.10.10/255 255 255 0 으로 만들고
3.써드는 10.10.10.30으로 만들고
4.확인 ![image](https://user-images.githubusercontent.com/76859458/115331707-5f0f3100-a1d1-11eb-95c0-ffa7a6743978.png)


장애조치 클러스터 구현
===
세컨드는 administrator@yonsai.com 입력하고 로그인한다음하기
세컨드가 NAS4Free의쿼럼 디스크와 클러스터 디스크를 각각 Q, R로 사용하도록 한다.
세컨드에서 서버관리자를 실행
![image](https://user-images.githubusercontent.com/76859458/115332167-3a678900-a1d2-11eb-97aa-d006fc2f9e7a.png)
그 다음에 예를 클릭
![image](https://user-images.githubusercontent.com/76859458/115332481-e0b38e80-a1d2-11eb-8f7a-b787e2f352c9.png)
![image](https://user-images.githubusercontent.com/76859458/115332542-00e34d80-a1d3-11eb-9ff3-4e53c1ffab90.png)
위에서나온 아이피는 NAS아이피다 포트란? 서비스 요청 번호 3260번은 iscsi를 연결하는 서비스 요청 번호이다
![image](https://user-images.githubusercontent.com/76859458/115333204-36d50180-a1d4-11eb-9cf6-d35dc6133f79.png)
나스 키고 해라
![image](https://user-images.githubusercontent.com/76859458/115333860-56205e80-a1d5-11eb-8b3a-da56e716dfab.png)
![image](https://user-images.githubusercontent.com/76859458/115334705-cf6c8100-a1d6-11eb-85b5-4990871fdda0.png)
확인클릭
연결시킨다음
![image](https://user-images.githubusercontent.com/76859458/115339925-b8cb2780-a1e0-11eb-97e2-01194c7754f1.png)
![image](https://user-images.githubusercontent.com/76859458/115340267-5161a780-a1e1-11eb-8848-c3074365cff7.png)
![image](https://user-images.githubusercontent.com/76859458/115340344-6e967600-a1e1-11eb-855d-43ce6ac9255e.png)
온라인 변환 초기화
![image](https://user-images.githubusercontent.com/76859458/115340802-612dbb80-a1e2-11eb-8c43-dd29d2779865.png)
Q드라이브와 R드라이브에 아무파일이나 복사해서 붙여 넣는다
![image](https://user-images.githubusercontent.com/76859458/115341744-19a82f00-a1e4-11eb-9b06-4b759b2ba4f9.png)
업데이트할려면 디스크를 오프라인 하고 온라인 이렇게 하는 이유는 vmware의 한계라서 그렇다 
써드도 동일진행
써드에서 디스크 확인
* * *
![image](https://user-images.githubusercontent.com/76859458/115345035-2b400580-a1e9-11eb-8463-c059470af2b6.png)
![image](https://user-images.githubusercontent.com/76859458/115345352-a4d7f380-a1e9-11eb-8159-60f593de777d.png)
![image](https://user-images.githubusercontent.com/76859458/115345682-1b74f100-a1ea-11eb-821f-3b16f179f41b.png)
second에서 도구에서 장애조치 클러스터 관리자를 선택한다
![image](https://user-images.githubusercontent.com/76859458/115479187-d8b32780-a282-11eb-9481-4ff2d7f04f28.png)
구성의 유효성검사 클릭(오른쪽 위)


* * *

[시작하기 전]화면에서 <다음>을 클릭
[서버 또는 클러스터 선택]화면에서 찾아보기 >> 고급 >> 지금찾기 >yonsai.com도메인 컴퓨터들이 보인다
이중 클러스터에 참여할 second와 third shift를 누르고 함께 선택한후 확인을 두번 클릭한다
테스트옵션 창에서 기본적인 모든 테스트 실행이 선택된 상태에서 다음 클릭
테스트 끝난뒤 검사된 노드를 사용하여 ~를 체크하고 마침 클릭
실패하면 다시 한번더 구성 유효성 검사를 수행해본다
![image](https://user-images.githubusercontent.com/76859458/115483298-77438680-a28b-11eb-8386-d21650ff8663.png)
알아서 넣어라
![image](https://user-images.githubusercontent.com/76859458/115483324-888c9300-a28b-11eb-80fd-80efa7416ddc.png)
![image](https://user-images.githubusercontent.com/76859458/115484295-84617500-a28d-11eb-864d-c53531a62273.png)
![image](https://user-images.githubusercontent.com/76859458/115484430-c4c0f300-a28d-11eb-8de6-5d87b12d6997.png)
![image](https://user-images.githubusercontent.com/76859458/115484919-9ee81e00-a28e-11eb-98d4-264c7b86d64f.png)

클러스터 만들기 마법사의 시작하기 전 화면에서 다음을 클릭한다
클러스터 관리 엑세스 지점 창에서 클러스터 이름을 적절히 ThisCluster정도로 입력한다
그리고 네트워크 주소를 사용하지 않는 아무거나 입력한다 192.168.111.222 다음을 클릭한다
확인창에서 입력된 접오를 확인하고 다음을 클릭한다 잠시 클러스터를 구성한다
성공적으로  클러스터가 생성되면 다음과 같이 보인다. 마침을 클릭한다(경고는 무시해도 된다)
써드에서 장애조치클러스터 관리자를 확인한다
세컨드에서 장애 조치 클러스터를 구성했으므로 Third에서 다시 구성할 필요는 없다
서버관리자 메뉴에서 도구 >> 장애조치 클러스터 관리자를 확인하면 동일하게 확인됨
vmware의 특성상 NAS4Free디스크의 연결이 끊어졌을수도 있다 다시 연결해 준다
이미 언급했지만 소프트웨어 방식으로 vmware 안에서 nas를 구현했기 때문에 완전하게 작동되지 않는다
자주 디스크를 확인해서 조치를 취해줘야 한다
Nas4free에서 7을 입력하고 enter를 눌러 재부팅한다 확인 창에서 tab키를 눌러 yes로 이동한 후  enter를 누른다
세컨드 써드 nas4free가 다시 완전히 재부팅된 후에 windows의 시작에서 마우스 오른쪽 버튼을 클릭하고
디스크 관리를 실행해서 디스크1과 디스크2를 온라인시킨다 

![image](https://user-images.githubusercontent.com/76859458/115487204-2b94db00-a293-11eb-99d8-ddc0cb9c0e76.png)
![image](https://user-images.githubusercontent.com/76859458/115487553-e7560a80-a293-11eb-9dd2-c91ab2efaba3.png)
![image](https://user-images.githubusercontent.com/76859458/115487628-0fde0480-a294-11eb-9ad7-4f015d3d0e47.png)

ssl
===
즉, SSL 암호화 통신은 'SSL(Secure Socket Layer)' 또는 'TLS(Transport Layer Security)'라는 보안 프로토콜을 통해 클라이언트(브라우저)와 
서버(웹서버)가 보안이 향상된 통신을 하는 것을 말합니다
https에서 s의약자가 ssl이다











FTP
===
![image](https://user-images.githubusercontent.com/76859458/115491327-b7f6cc00-a29a-11eb-9dd1-a97463083e6e.png)
SECOND에서 FTP 서비스를 설치
![image](https://user-images.githubusercontent.com/76859458/115491870-b8dc2d80-a29b-11eb-8123-4e0dd9da5ef3.png)
![image](https://user-images.githubusercontent.com/76859458/115492912-b37fe280-a29d-11eb-9746-464b95056d89.png)
웹서버 추가 https://medium.com/@jw02048/%EC%9B%B9%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-a51942140bb8     
써드에서도 똑같이 추가한다
세컨드에서 FTP 서버를 설정한다
서버관리자의 메뉴에서도구 >> IIS(인터넷 정보 서비스) 관리자를 선택해서 실행한다
IIS(인터넷정보 서비스) 관리자에서 왼쪽 SECOND를 확장한다
![image](https://user-images.githubusercontent.com/76859458/115499680-cbaa2e80-a2aa-11eb-8b5e-65b6509f3117.png)
![image](https://user-images.githubusercontent.com/76859458/115500189-cac5cc80-a2ab-11eb-9747-3807790967d3.png)
![image](https://user-images.githubusercontent.com/76859458/115500864-1c228b80-a2ad-11eb-8485-c962b15b305a.png)
![image](https://user-images.githubusercontent.com/76859458/115500938-41af9500-a2ad-11eb-8980-9cec4115b358.png)
R드라이브에 ftphome 폴더에 배포할 파일을 아무거나 몇 개 복사한다
써드 세컨드와 동일하게 ftp서버를 구축한다


세컨드와 써드에서 각각의 FTP 서비스가 작동중이다. 이를 가상 서버로 통합하자..
![image](https://user-images.githubusercontent.com/76859458/115505677-cbaf2c00-a2b4-11eb-8507-ba515290c2c2.png)
![image](https://user-images.githubusercontent.com/76859458/115506328-b38bdc80-a2b5-11eb-926c-2154bf1980ee.png)
![image](https://user-images.githubusercontent.com/76859458/115506437-d0c0ab00-a2b5-11eb-8d76-883c569562d6.png)
![image](https://user-images.githubusercontent.com/76859458/115506590-fcdc2c00-a2b5-11eb-868c-4c77e982b071.png)
![image](https://user-images.githubusercontent.com/76859458/115506855-55abc480-a2b6-11eb-978d-cc3ed77d7828.png)


